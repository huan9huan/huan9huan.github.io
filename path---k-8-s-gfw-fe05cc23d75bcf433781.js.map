{"version":3,"sources":["webpack:///path---k-8-s-gfw-fe05cc23d75bcf433781.js","webpack:///./.cache/json/k-8-s-gfw.json"],"names":["webpackJsonp","403","module","exports","data","site","siteMetadata","title","author","markdownRemark","id","html","frontmatter","date","pathContext","slug","previous","fields","next"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,MAAQC,cAAgBC,MAAA,eAAAC,OAAA,eAA8CC,gBAAmBC,GAAA,yFAAAC,KAAA,w8GAAsnGC,aAAkeL,MAAA,aAAAM,KAAA,wBAAmDC,aAAgBC,KAAA,YAAAC,UAA+BC,QAAUF,KAAA,iBAAuBH,aAAgBL,MAAA,iBAAwBW,MAASD,QAAUF,KAAA,oCAA0CH,aAAgBL,MAAA","file":"path---k-8-s-gfw-fe05cc23d75bcf433781.js","sourcesContent":["webpackJsonp([208401280037608],{\n\n/***/ 403:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"site\":{\"siteMetadata\":{\"title\":\"huan9huan的博客\",\"author\":\"huang huan\"}},\"markdownRemark\":{\"id\":\"/Users/alhuang/work/blog/src/pages/k8s-gfw/index.md absPath of file >>> MarkdownRemark\",\"html\":\"<p>一直用docker，但是感觉docker总是独立的用，除了解决打包的问题，应用的依赖关系还是表达的很不好。\\n这次在极客时间上有张磊开的k8s的课程，果断入手买了。</p>\\n<p>学到了k8s的安装，就碰到了棘手的翻墙问题（我是在阿里云上CentOS实验和学习的），核心问题是两个：</p>\\n<blockquote>\\n<ol>\\n<li>kubeadm的安装，因为yum/apt源使用packages.cloud.google.com而无法访问的问题</li>\\n<li>gcr.io 无法访问从而造成k8s启动所必须的的images无法拉取</li>\\n<li>kubeadm init的时候，远程探测版本撞墙问题</li>\\n</ol>\\n</blockquote>\\n<p>一个个解决。</p>\\n<h2>Problem 1: kubeadm的yum安装</h2>\\n<p>方法尝试用了两个，一个是shadowsocks代理（前提你要有国外的vps），一个是使用aliyun自己的yum镜像，后者相对简单一些。</p>\\n<p>按照通常的方法，要求加入一个kubernetes.repo的源:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-text\\\"><code class=\\\"language-text\\\">cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo\\n[kubernetes]\\nname=Kubernetes\\n#baseurl=https://packages.cloud.google.com/yum/repos/kubernetes-el7-x86_64\\nbaseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64\\nenabled=1\\ngpgcheck=0\\nEOF\\n\\nyum -y install epel-release\\nyum clean all\\nyum makecache</code></pre>\\n      </div>\\n<p>然后安装 kubeadm和kubelet应该成功：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-text\\\"><code class=\\\"language-text\\\">yum -y install kubelet kubeadm kubectl \\nkubelet --version</code></pre>\\n      </div>\\n<p>注意我这里的版本是 v1.11.3，下面会用。</p>\\n<h2>Problem 2: k8s.gcr.io 访问问题</h2>\\n<p>因为k8s的Static Pod启动需要从 k8s.gcr.io 上拉取必要的镜像，但是这个网站上被封掉了，所以需从别的镜像中拉取这些镜像，然后tag成为 k8s.gcr.io 开头，然后 dockerd就可以从本地拉取了镜像。国内的镜像我使用了 <code class=\\\"language-text\\\">registry.cn-hangzhou.aliyuncs.com/google_containers</code> 看起来同步的不错。</p>\\n<p>运行脚本是这样的：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-text\\\"><code class=\\\"language-text\\\">MY_REGISTRY=registry.cn-hangzhou.aliyuncs.com/google_containers\\n#registry.cn-hangzhou.aliyuncs.com/google-images\\nVERSION=v1.11.3\\n\\n## 拉取镜像\\ndocker pull ${MY_REGISTRY}/kube-apiserver-amd64:${VERSION}\\ndocker pull ${MY_REGISTRY}/kube-controller-manager-amd64:${VERSION}\\ndocker pull ${MY_REGISTRY}/kube-scheduler-amd64:${VERSION}\\ndocker pull ${MY_REGISTRY}/kube-proxy-amd64:${VERSION}\\ndocker pull ${MY_REGISTRY}/etcd-amd64:3.2.18\\ndocker pull ${MY_REGISTRY}/pause-amd64:3.1\\ndocker pull ${MY_REGISTRY}/coredns:1.1.3\\ndocker pull ${MY_REGISTRY}/pause:3.1\\n\\n## 添加Tag\\ndocker tag ${MY_REGISTRY}/kube-apiserver-amd64:${VERSION} k8s.gcr.io/kube-apiserver-amd64:${VERSION}\\ndocker tag ${MY_REGISTRY}/kube-scheduler-amd64:${VERSION} k8s.gcr.io/kube-scheduler-amd64:${VERSION}\\ndocker tag ${MY_REGISTRY}/kube-controller-manager-amd64:${VERSION} k8s.gcr.io/kube-controller-manager-amd64:${VERSION}\\ndocker tag ${MY_REGISTRY}/kube-proxy-amd64:${VERSION} k8s.gcr.io/kube-proxy-amd64:${VERSION}\\ndocker tag ${MY_REGISTRY}/etcd-amd64:3.2.18 k8s.gcr.io/etcd-amd64:3.2.18\\ndocker tag ${MY_REGISTRY}/pause-amd64:3.1 k8s.gcr.io/pause-amd64:3.1\\ndocker tag ${MY_REGISTRY}/coredns:1.1.3 k8s.gcr.io/coredns:1.1.3\\ndocker tag ${MY_REGISTRY}/pause:3.1 k8s.gcr.io/pause:3.1</code></pre>\\n      </div>\\n<p>注意：</p>\\n<blockquote>\\n<ol>\\n<li>不同的版本需要特定version的image，如果长期跟踪kubeadm和kubectl，要注意维护这个image列表  </li>\\n<li>如果使用代理方案，注意 <code class=\\\"language-text\\\">http_proxy=&lt;proxy address&gt;:&lt;proxy port&gt; docker pull</code> 并不能生效，而是要让docker daemon感知到proxy的存在。这是一个坑点，但不是docker的设计缺陷，而是image pull的操作是docker服务进程管理的，当然代理要让这个进程使用。</li>\\n</ol>\\n</blockquote>\\n<h3>Problem 3: 一个小尾巴，关闭版本探测</h3>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-text\\\"><code class=\\\"language-text\\\">kubeadm init --kubernetes-version=v1.11.3</code></pre>\\n      </div>\\n<p>否则kubeadm会访问一个墙外的文件，找这个版本， 也会卡住。</p>\\n<p>然后就可以愉快的玩k8s了，真呀嘛真好用，不浪费这一番折腾。</p>\\n<h3>墙很害人，但是墙让人更加强壮，不会翻墙，就被淘汰</h3>\",\"frontmatter\":{\"title\":\"k8s安装的翻墙攻略\",\"date\":\"September 19, 2018\"}}},\"pathContext\":{\"slug\":\"/k8s-gfw/\",\"previous\":{\"fields\":{\"slug\":\"/walk-or-run/\"},\"frontmatter\":{\"title\":\"是走还是跑，这是一个问题\"}},\"next\":{\"fields\":{\"slug\":\"/make-learning-more-deep/README/\"},\"frontmatter\":{\"title\":\"屠龙技是否有用的关键是是否精通了它\"}}}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---k-8-s-gfw-fe05cc23d75bcf433781.js","module.exports = {\"data\":{\"site\":{\"siteMetadata\":{\"title\":\"huan9huan的博客\",\"author\":\"huang huan\"}},\"markdownRemark\":{\"id\":\"/Users/alhuang/work/blog/src/pages/k8s-gfw/index.md absPath of file >>> MarkdownRemark\",\"html\":\"<p>一直用docker，但是感觉docker总是独立的用，除了解决打包的问题，应用的依赖关系还是表达的很不好。\\n这次在极客时间上有张磊开的k8s的课程，果断入手买了。</p>\\n<p>学到了k8s的安装，就碰到了棘手的翻墙问题（我是在阿里云上CentOS实验和学习的），核心问题是两个：</p>\\n<blockquote>\\n<ol>\\n<li>kubeadm的安装，因为yum/apt源使用packages.cloud.google.com而无法访问的问题</li>\\n<li>gcr.io 无法访问从而造成k8s启动所必须的的images无法拉取</li>\\n<li>kubeadm init的时候，远程探测版本撞墙问题</li>\\n</ol>\\n</blockquote>\\n<p>一个个解决。</p>\\n<h2>Problem 1: kubeadm的yum安装</h2>\\n<p>方法尝试用了两个，一个是shadowsocks代理（前提你要有国外的vps），一个是使用aliyun自己的yum镜像，后者相对简单一些。</p>\\n<p>按照通常的方法，要求加入一个kubernetes.repo的源:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-text\\\"><code class=\\\"language-text\\\">cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo\\n[kubernetes]\\nname=Kubernetes\\n#baseurl=https://packages.cloud.google.com/yum/repos/kubernetes-el7-x86_64\\nbaseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64\\nenabled=1\\ngpgcheck=0\\nEOF\\n\\nyum -y install epel-release\\nyum clean all\\nyum makecache</code></pre>\\n      </div>\\n<p>然后安装 kubeadm和kubelet应该成功：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-text\\\"><code class=\\\"language-text\\\">yum -y install kubelet kubeadm kubectl \\nkubelet --version</code></pre>\\n      </div>\\n<p>注意我这里的版本是 v1.11.3，下面会用。</p>\\n<h2>Problem 2: k8s.gcr.io 访问问题</h2>\\n<p>因为k8s的Static Pod启动需要从 k8s.gcr.io 上拉取必要的镜像，但是这个网站上被封掉了，所以需从别的镜像中拉取这些镜像，然后tag成为 k8s.gcr.io 开头，然后 dockerd就可以从本地拉取了镜像。国内的镜像我使用了 <code class=\\\"language-text\\\">registry.cn-hangzhou.aliyuncs.com/google_containers</code> 看起来同步的不错。</p>\\n<p>运行脚本是这样的：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-text\\\"><code class=\\\"language-text\\\">MY_REGISTRY=registry.cn-hangzhou.aliyuncs.com/google_containers\\n#registry.cn-hangzhou.aliyuncs.com/google-images\\nVERSION=v1.11.3\\n\\n## 拉取镜像\\ndocker pull ${MY_REGISTRY}/kube-apiserver-amd64:${VERSION}\\ndocker pull ${MY_REGISTRY}/kube-controller-manager-amd64:${VERSION}\\ndocker pull ${MY_REGISTRY}/kube-scheduler-amd64:${VERSION}\\ndocker pull ${MY_REGISTRY}/kube-proxy-amd64:${VERSION}\\ndocker pull ${MY_REGISTRY}/etcd-amd64:3.2.18\\ndocker pull ${MY_REGISTRY}/pause-amd64:3.1\\ndocker pull ${MY_REGISTRY}/coredns:1.1.3\\ndocker pull ${MY_REGISTRY}/pause:3.1\\n\\n## 添加Tag\\ndocker tag ${MY_REGISTRY}/kube-apiserver-amd64:${VERSION} k8s.gcr.io/kube-apiserver-amd64:${VERSION}\\ndocker tag ${MY_REGISTRY}/kube-scheduler-amd64:${VERSION} k8s.gcr.io/kube-scheduler-amd64:${VERSION}\\ndocker tag ${MY_REGISTRY}/kube-controller-manager-amd64:${VERSION} k8s.gcr.io/kube-controller-manager-amd64:${VERSION}\\ndocker tag ${MY_REGISTRY}/kube-proxy-amd64:${VERSION} k8s.gcr.io/kube-proxy-amd64:${VERSION}\\ndocker tag ${MY_REGISTRY}/etcd-amd64:3.2.18 k8s.gcr.io/etcd-amd64:3.2.18\\ndocker tag ${MY_REGISTRY}/pause-amd64:3.1 k8s.gcr.io/pause-amd64:3.1\\ndocker tag ${MY_REGISTRY}/coredns:1.1.3 k8s.gcr.io/coredns:1.1.3\\ndocker tag ${MY_REGISTRY}/pause:3.1 k8s.gcr.io/pause:3.1</code></pre>\\n      </div>\\n<p>注意：</p>\\n<blockquote>\\n<ol>\\n<li>不同的版本需要特定version的image，如果长期跟踪kubeadm和kubectl，要注意维护这个image列表  </li>\\n<li>如果使用代理方案，注意 <code class=\\\"language-text\\\">http_proxy=&lt;proxy address&gt;:&lt;proxy port&gt; docker pull</code> 并不能生效，而是要让docker daemon感知到proxy的存在。这是一个坑点，但不是docker的设计缺陷，而是image pull的操作是docker服务进程管理的，当然代理要让这个进程使用。</li>\\n</ol>\\n</blockquote>\\n<h3>Problem 3: 一个小尾巴，关闭版本探测</h3>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-text\\\"><code class=\\\"language-text\\\">kubeadm init --kubernetes-version=v1.11.3</code></pre>\\n      </div>\\n<p>否则kubeadm会访问一个墙外的文件，找这个版本， 也会卡住。</p>\\n<p>然后就可以愉快的玩k8s了，真呀嘛真好用，不浪费这一番折腾。</p>\\n<h3>墙很害人，但是墙让人更加强壮，不会翻墙，就被淘汰</h3>\",\"frontmatter\":{\"title\":\"k8s安装的翻墙攻略\",\"date\":\"September 19, 2018\"}}},\"pathContext\":{\"slug\":\"/k8s-gfw/\",\"previous\":{\"fields\":{\"slug\":\"/walk-or-run/\"},\"frontmatter\":{\"title\":\"是走还是跑，这是一个问题\"}},\"next\":{\"fields\":{\"slug\":\"/make-learning-more-deep/README/\"},\"frontmatter\":{\"title\":\"屠龙技是否有用的关键是是否精通了它\"}}}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/k-8-s-gfw.json\n// module id = 403\n// module chunks = 208401280037608"],"sourceRoot":""}